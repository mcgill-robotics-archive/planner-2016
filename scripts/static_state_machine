#!/usr/bin/python
import smach
import smach_ros
import rospy
from threading import Thread
from planner import *
from planner.msg import *
from smach_ros import SimpleActionState

from actionlib import *
from actionlib_msgs.msg import *
from std_msgs.msg import Empty
#from planner.msg import initializeAction, initializeGoal, initializeResult, initializeFeedback, moveAction, moveGoal, moveFeedback, moveResult
import initialize_server,move_server









def instastopper(outcome_map):
    if outcome_map['Monitor'] == 'invalid':
        return True
    return False

def out_cb(outcome_map):
        return 'done'
    
    
    

#callbacks for move, parameter reading will be moved out of the goal callback for an easier time
#(only the first and last 3 lines of that callback will remain)
def move_goal_cb(userdata,goal):
    counter = userdata.uid
    
    params = rospy.get_param('~/move'+str(counter))
    time = rospy.Time(params.time[0],params.time[1])
    velocity = geometry_msgs.Twist(Vector3(params.velocity[0],params.velocity[1],params.velocity[2]),Vector3(params.velocity[3],params.velocity[4],params.velocity[5]))
    move_goal = moveGoal(time,velocity,params.theta,params.depth)
    userdata.uid += 1
    return move_goal
#TODO: make this callback less limited and allow more arbitrary IDs
def move_result_cb(userdata,status,goal):
    if status == GoalStatus.SUCCEEDED:
        if userdata.uid==4:
            userdata.uid = 0
            return 'done'
        else:
            return 'notdone'


import random





def monitor_cb(ud, msg):
    return False


def create_machine():
    
    square_concurrence = smach.Concurrence(outcomes=['done'],
                                           default_outcome=['done'],
                                           child_termination_cb=instastopper,
                                           outcome_cb=out_cb)
    with square_concurrence:
        
        smach.Concurrence.add('Initialize',
                               SimpleActionState('init_action',
                                               initializeAction,
                                               goal=initializeGoal(countdown=countdown1)),
                               transitions={'succeeded':'Move'})

        smach.Concurrence.add('Move',
                               SimpleActionState('square_action',
                                               moveAction,
                                               goal_cb=move_goal_cb,
                                               result_cb=move_result_cb,
                                               outcomes=['done','notdone']),
                               transitions={'notdone':'Move'})

        smach.Concurrence.add('Monitor', smach_ros.MonitorState("/sm_reset", Empty, monitor_cb))


    static_sm = smach.StateMachine(outcomes=['done'])
    
    with static_sm:
        #countdown = rospy.get_param('countdown')
        #countdown1 = rospy.Time(10)
        #static_sm.userdata.uid = 0 
        smach.StateMachine.add('Idle',
                               smach_ros.MonitorState("/sm_reset", Empty, monitor_cb),
                               transitions={'invalid':'Square',
                                            'valid':'Idle',
                                            'preempted':'Idle',
                                            'aborted':'Idle'})
        smach.StateMachine.add('Square', square_concurrence, transitions={'done':'Idle'})  

    return static_sm
                               
                                               
        
        


























if __name__ == '__main__':
    rospy.init_node('square_state_machine',log_level=rospy.DEBUG)
    
    server1 = initialize_server.InitializeServer('init_action')
    server2 = move_server.MoveAction('square_action')
    
    sm = create_machine()
 
    sis = smach_ros.IntrospectionServer('square_state_machine', sm, '/SM_ROOT')
    sis.start  #taken from the threading method used in auv-2015 to avoid problems
    smach_thread = Thread(target=lambda: sm.execute())
    smach_thread.start()

    #taken from auv-2015 to avoid the ctrl+c issue
    rospy.on_shutdown(sm.request_preempt)
    sm.execute()
    rospy.spin()
    
    
    
    smach_thread.join()
    sis.stop()
    
