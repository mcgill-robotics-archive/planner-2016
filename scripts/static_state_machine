#!/usr/bin/python

import smach
import smach_ros
import rospy
from threading import Thread
from planner import *
import initialize_server,move_server
from smach_ros import SimpleActionState
from actionlib import *
from actionlib_msgs.msg import *
from planner.msg import initializeAction, initializeGoal, initializeResult, initializeFeedback, moveAction, moveGoal, moveFeedback, moveResult






#condition callback for idle since it is a condition state
#TODO: setup to condition on a topic instead

##def idle_cond_cb(ud):
##    check = raw_input()
##    if check == 1:
##        return True
##    else:
##        return False

class Idle(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['outcome1'])
    # Your state initialization goes here

    def execute(self, userdata):
    # Your state execution goes here
        rospy.loginfo('idle')
        return 'outcome1'
 
    

#callbacks for move, parameter reading will be moved out of the goal callback for an easier time
#(only the first and last 3 lines of that callback will remain)
def move_goal_cb(userdata,goal):
    counter = userdata.uid
    
    params = userdata.moves[uid]
    time = RosTime(params[0],params[1])
    velocity = Twist(Vector3(params[2],params[3],params[4]),Vector3(params[5],params[6],params[7]))
    move_goal = MoveGoal(time,velocity,params[8],params[9])
    userdata.uid += 1
    return move_goal
#TODO: make this callback less limited and allow more arbitrary IDs
def move_result_cb(userdata,status,goal):
    if status == GoalStatus.SUCCEEDED:
        if userdata.uid==4:
            userdata.uid = 0
            return 'done'
        else:
            return 'notdone'


import random

class InitializeServer(object):
    _feedback = initializeFeedback()
    _result = initializeResult()
    


    def __init__(self, name):
        rospy.loginfo(self.execute_cb)
        
        self._as = SimpleActionServer(name, initializeAction, execute_cb=self.execute_cb, auto_start=False)
        
        
        self._as.start()

    def execute_cb(self,goal):
        rospy.loginfo('starting')
        t = goal
        seconds = t.to_sec() #floating point
        nanoseconds = t.to_nsec()

        for s in range(t,1.0,-1.0):
             if self._as.is_preempt_requested():
                rospy.loginfo('%s: Preempted' % self._action_name)
                self._as.set_preempted()
                success = False
                break
             rand = random.randint(0,1)
            
                
             self._feedback.time_left = rospy.Time.from_sec(s)
             self._as.publish_feedback(self._feedback)
             if rand == 0:
                 self._result.offset = Pose(Point(10,10,10),Quaternion(20,20,20,20))
                 rospy.loginfo('%s: Succeeded' % self._action_name)
                 self._as.set_succeeded(self._result)
                 break
             rospy.Rate(1).sleep()


        rospy.loginfo('%s: Preempted' % self._action_name)
        self._as.set_preempted()


def create_machine():
    static_sm = smach.StateMachine(
        outcomes=['succeeded','aborted','preempted'])
    
    with static_sm:
        #countdown = rospy.get_param('countdown')
        countdown1 = rospy.Time(10,0)
        static_sm.userdata.uid = 0 
        static_sm.userdata.moves = [10,0,1,1,1,1,1,1,30,10]
        
        
        smach.StateMachine.add('Idle',
                               Idle(),
                               transitions={'outcome1':'Initialize'})
        smach.StateMachine.add('Initialize',
                               SimpleActionState('initaction',
                                               initializeAction,
                                               goal=initializeGoal(countdown=countdown1)),
                               transitions={'succeeded':'Move',
                                            'preempted':'Idle'})
        smach.StateMachine.add('Move',
                               SimpleActionState('squareaction',
                                               moveAction,
                                               goal_cb=move_goal_cb,
                                               result_cb=move_result_cb,
                                               outcomes=['done','notdone']),
                               transitions={'notdone':'Move',
                                            'done':'Idle'})
    return static_sm
                               
                                               
        
        


























if __name__ == '__main__':
    rospy.init_node('square_state_machine', log_level=rospy.WARN)
    server1 = InitializeServer('initaction')
    server2 = move_server.MoveAction('squareaction')
    sm = create_machine()
 
    #sis = smach_ros.IntrospectionServer('square_state_machine', sm, '/SM_ROOT')
    #sis.start()

    #taken from the threading method used in auv-2015 to avoid problems
    #smach_thread = Thread(target=lambda: sm.execute())
    #smach_thread.start()

    #taken from auv-2015 to avoid the ctrl+c issue
    rospy.on_shutdown(sm.request_preempt)
    rospy.spin()
    #smach_thread.join()
    #sis.stop()
    
