#!/usr/bin/python
import smach
import smach_ros
import rospy
import yaml
import taskr
from threading import Thread
#from planner import *
from planner.msg import TaskGoal, TaskAction
from smach_ros import SimpleActionState

from actionlib import *
from actionlib_msgs.msg import *
from std_msgs.msg import Bool
#from src import Task


res = 'succeeded'

class Act(smach.State):
    def __init__(self, task_name):
        smach.State.__init__(self,
                             outcomes = ['succeeded', 'preempted'])
        self.task_name = task_name
        self.res = 'succeeded'


    def doneCb(self, status, result):
        print('Done!')
        if status == GoalStatus.SUCCEEDED:
            self.res = 'succeeded'
        else:
            self.res =  'preempted'

    def activeCb(self):
        print('Active!')

    def feedbackCb(self, feedback2):
        if self.preempt_requested():
                rospy.loginfo('Cancel')
                client.cancel_goal()
                client.service_preempt()
                self.res = 'preempted'

    def execute(self, userdata):
        client = SimpleActionClient(self.task_name + "_task", TaskAction)
        client.wait_for_server()
        goal = TaskGoal(task=self.task_name)
        #client.send_goal(goal, self.doneCb, self.activeCb, self.feedbackCb)
        client.send_goal(goal)
        #client.wait_for_result()
        while not rospy.is_shutdown():
            if self.preempt_requested():
                rospy.loginfo('Cancel')
                client.cancel_all_goals()
                client.service_preempt()
                self.res = 'preempted'
                break
            if client.simple_state == SimpleGoalState.DONE:
                break



        #self.res = done_cb
        return self.res


'''This stops everything (set back to idle) when  the kill switch triggers'''


def instastopper2(outcome_map):
    if outcome_map['Monitor'] == 'invalid' or outcome_map['Movement'] == 'succeeded' or outcome_map['Movement']=='preempted' or outcome_map['Movement'] == 'aborted':
        rospy.loginfo('Monitor')
        return True
    return False

'''These 2 callbacks define the behavior of the monitors, what happens when they receive
a particular signal on the topic they are monitoring'''


def monitor_cb_start(ud, msg):
    if msg.data is True:
        rospy.loginfo('Starting!!')
        return False
    else:
        return True


def monitor_cb_stop(ud, msg):
    if msg.data is False:
        rospy.loginfo('Stopping!')
        return False
    else:
        return True

'''What happens when idle and move states finish'''
def out_idle_cb(outcome_map):
    rospy.sleep(5)
    if outcome_map['Monitor'] == 'invalid':
        return 'invalid'
    else:
        return 'valid'


def out_task_cb(outcome_map):
    rospy.sleep(3.5)
    return 'succeeded'


def create_machine():



    static_sm = smach.StateMachine(outcomes=['succeeded', 'preempted', 'aborted'])

    with open(yaml.load('/home/tortue/auv/catkin_ws/src/planner/config/combinedtasks.yaml')) as f:
        task_list = yaml.load(f)
        rospy.loginfo(task_list['tasks'])


    seq = smach.Sequence(
                    outcomes=['succeeded', 'preempted', 'aborted'],
                    connector_outcome='succeeded')

    with seq:
        for tasks in range(len(task_list['tasks'])):
            rospy.loginfo(tasks)
            task_name = task_list['tasks'][tasks]['name']
            print(task_name)
            execution_concurrence = smach.Concurrence(outcomes=['succeeded','preempted','aborted'],
                                                      default_outcome='succeeded',
                                                      child_termination_cb=instastopper2,
                                                      outcome_cb=out_task_cb)
            with execution_concurrence:
                smach.Concurrence.add('Movement', Act(task_name))
                smach.Concurrence.add('Monitor', smach_ros.MonitorState("/sm_reset", Bool, monitor_cb_stop))

            smach.Sequence.add(task_name + '_task', execution_concurrence)

    # execution_concurrence = smach.Concurrence(outcomes=['succeeded','preempted','aborted'],
    #                                           default_outcome='succeeded',
    #                                           child_termination_cb=instastopper2,
    #                                           outcome_cb=out_task_cb)
    # with execution_concurrence:
    #     smach.Concurrence.add('Movement', seq)
    #
    #     smach.Concurrence.add('Monitor', smach_ros.MonitorState("/sm_reset", Bool, monitor_cb_stop))

    idle_concurrence = smach.Concurrence(outcomes=['valid', 'invalid'],
                                         default_outcome='valid',
                                         outcome_cb=out_idle_cb)

    with idle_concurrence:
        smach.Concurrence.add('Monitor', smach_ros.MonitorState("/sm_reset", Bool, monitor_cb_start))

    with static_sm:

        smach.StateMachine.add('Idle',
                               idle_concurrence,
                               transitions={'invalid': 'Movement',
                                            'valid': 'Idle'})

        smach.StateMachine.add('Movement', seq, transitions={'succeeded':'Idle',
                                                                               'preempted':'Idle'})

    return static_sm


if __name__ == '__main__':

    rospy.init_node('fake_planner_client')
    #server = task_server.TaskAction('task_action')


    sm = create_machine()

  #taken from the threading method used in auv-2015 to avoid problems

    #taken from auv-2015 to avoid the ctrl+c issue

    sm.execute()
    rospy.spin()
